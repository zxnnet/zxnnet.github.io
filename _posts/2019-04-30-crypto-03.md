---
layout: article
title: 密码学基础学习总结-03
tags: 现代密码学 AES DES 总结 笔记
mode: immersive
key: k20
aside:
  toc: true
header:
  theme: dark
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
    src: https://i.loli.net/2019/04/30/5cc80c057abbb.jpg
---

# 密码学基础总结-03

迈入现代密码学的大门，在这篇文章里面将开始现代密码学的内容。

## 什么是现代密码学

现代密码学与古典密码学到底有什么区别呢？在这里的现代密码学指的比较广泛，你可以说“真现代”是非对称密码学，这里的现代还是把对称加上。与古典密码学有很大的区别。

- 在二进制位上进行操作，这样简单的针对特定语言的频率攻击将无效化，二进制不依赖于特定的人类语言。
- 保护密钥，不保密算法，算法应该公开接受全地球人的检验攻击，如果大家都认为这个算法好，攻击不动才能使用，这也就是**柯克霍夫原则**（Kerckhoffs's principle，也称为柯克霍夫假说、公理、或定律），这样才能保证安全性，也可以延伸概念到开源软件这个概念中，开源万岁！
- 同一明文多次加密，每次的密文均不相同，这条我认为也应该算在现代密码学相对于古典密码学的区别中，只有这样才能抵抗选择明文攻击。

我暂时能想出来这么多种，如果有人知道更多，务必告诉我，我会添加进去。

## 对称加密？非对称加密？

现代密码学中，有对称加密和非对称加密，对称加密需要预共享密钥，如何共享这个密钥是个很大的问题，在互联网时代没有什么安全的通讯信道给你共享密钥的，所以天才们发明了非对称加密，在非对称加密中，公钥公开用于加密，私钥保留用作解密，这样就能解决预共享密钥困难的问题，攻击者知道公钥也无法知道私钥，无法解密别人发的消息。

那听起来非对称加密简直是太完美了，我们全部使用非对称加密吧，但是凡事都要付出代价，对称加密速度快，代价小，非对称加密代价大，有很多限制，解密加密都要慢，在实际中我们常常采用非对称来共享密钥，之后用对称加密传输信息。下面我们先来看对称加密算法。

## 对称加密

我们先回忆一次一密，在一次一密中，密钥随机和密文等长。但是在实际的情况下，我们的密钥无法做到和密文等长而且完全随机，试想你要传输一个几十GB的数据，你要生成一个相同大小的密钥，密钥还要共享到接收方，头大，所以实际中会选用一个小的密钥来加解密，有下面两种策略：

### 加密算法设计的两种基本策略

#### 流密码(序列密码,Stream Cipher)

◼ 将密钥扩展到与密文等长
◼ 加密算法一般为异或操作
◼ 其安全性主要在于**密钥扩展后的随机性**
$M = m _1 m_2 m_3 ..., K = k , C = c$
其中 $c = Enc_{k} ( M )$

#### 分组密码(Block Cipher)

◼ 将明文分成等长的分组(比如64位、128位)
◼ 对每个分组采用相同的加密算法进行加密
◼ 算法一般是交替使用混乱和扩散技术
$M = m _1 m_2 m_3 ...., K = k_1 k_2 k_3 ..., C = c_1 c_2 c_3 ...$
其中 $c_i = Enc_{k_i} ( m_i )$

这篇文章接下来将介绍流密码，和一个具体的例子RC4

## 流密码与伪随机数

### 序列加密算法

下面是一个简单的过程描述

1. Gen
   $n→k,k$是一个$[0,2^n]$均匀分布中随机取出的一个整数。
2. Enc
   $(k, m) → c$,$c\leftarrow G ( k ) \oplus  m$ 
3. Dec
   $(k, c) → m$; $m \leftarrow G ( k ) \oplus c$

其中$G$是一个伪随机数发生器，密钥的作用类似作为一个种子，打乱顺序，$G$根据密钥不断地生成伪随机数，相当于一个流一样，最后生成一个和明文等长的加密串之后异或运算，这就得到了密文，解密也是类似过程，密钥类似种子，在这里我们每次必须制定一个初始向量，也就是随机数，这样才能做到抵抗选择明文攻击（当然加密方的随机数要附加在密文中告诉解密方，要不然无法解密），这就是流密码的简单框架。

### RC4序列加密算法

##### 伪随机数发生器

伪随机数发生器的伪代码(生成伪随机数)

```pascal
i := j := 0
while GeneratingOutput:
	i := (i + 1) mod 256
	j := (j + S[i]) mod 256
	swap values of S[i] and S[j]
	SR:= S[(S[i] + S[j]) mod 256]
	output SR
endwhile
```

通过确定随机初始向量和秘钥来进行加密可以变为非确定性算法。这样我们就得到了一个简单的堆成加密体系，这个体系非常简单，但是人们好久也没有攻击成功，不过现在RC4已经被破解，下面来看一个过时的具体例子。

### WEP加密方案

该方案使用40-bit key + 24-bit IV：

![image.U3QD0Z](https://i.loli.net/2019/04/30/5cc815c16bfbb.png)

<center>WEP方案加密</center>

![image.R4FM0Z](https://i.loli.net/2019/04/30/5cc815d9cd5f3.png)

<center>WEP方案解密</center>

IV就是初始的随机数，$||$表示简单拼接，CRC-32是循环冗余检验，不在这个地方讨论，Plaintext是明文，$\oplus$ 是异或运算，RC4 PRNG就是上面说的RC4算法。

#### 缺陷

- WEP数据帧中第一个字节消息相同,攻击者可以得到第一个字节的G(k)值。
- IV只有24bits,$2^{12}$个消息就很可能出现碰撞。（生日攻击）
- 利用碰撞,相对容易猜测密文对应的明文。

之后也许你会说，这我看我增长初始向量和密钥长度不就新了，可是实际上还是不行，序列密码的安全性在于伪随机数发生器真的生成了看起来跟真的随机数一样东西，然而RC4没有做到，具体可以去搜索（其实是我太菜），总之现在人们不大用RC4在需要很安全的场景下。

幸好，我们还有分组加密算法，下一篇文章将介绍分组加密算法。